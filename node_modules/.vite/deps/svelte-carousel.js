import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  set_style,
  space,
  tick,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots
} from "./chunk-UJLIVLOQ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-DFKQJ226.js";

// node_modules/lodash.get/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.get/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol = root.Symbol;
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArray = Array.isArray;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get3(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get3;
  }
});

// node_modules/lodash.clonedeep/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep2(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep2;
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual2(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual2;
  }
});

// node_modules/svelte-carousel/src/components/Dot/Dot.svelte
var file = "node_modules\\svelte-carousel\\src\\components\\Dot\\Dot.svelte";
function add_css(target) {
  append_styles(target, "svelte-yu7247", ":root{--sc-dot-size:6px;--sc-active-dot-size:8px;--sc-dot-size-animation-time:250ms}.sc-carousel-dot__dot.svelte-yu7247{background-color:var(--sc-color-rgb-light);border-radius:50%;display:inline-block;opacity:0.5;transition:opacity 100ms ease,\r\n      height var(--sc-dot-size-animation-time) ease,\r\n      width var(--sc-dot-size-animation-time) ease;cursor:pointer;-webkit-tap-highlight-color:transparent;height:var(--sc-dot-size);width:var(--sc-dot-size)}.sc-carousel-dot__dot.svelte-yu7247:hover{opacity:0.9}.sc-carousel-dot__dot_active.svelte-yu7247{opacity:0.7;height:var(--sc-active-dot-size);width:var(--sc-active-dot-size)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG90LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFjRSxLQUFNLENBQ0osYUFBYSxDQUFFLEdBQUcsQ0FDbEIsb0JBQW9CLENBQUUsR0FBRyxDQUN6Qiw0QkFBNEIsQ0FBRSxLQUNoQyxDQUVBLG1DQUFzQixDQUNwQixnQkFBZ0IsQ0FBRSxJQUFJLG9CQUFvQixDQUFDLENBQzNDLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE9BQU8sQ0FBRSxZQUFZLENBQ3JCLE9BQU8sQ0FBRSxHQUFHLENBQ1osVUFBVSxDQUNSLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO0FBQ3pCLE1BQU0sTUFBTSxDQUFDLElBQUksNEJBQTRCLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDcEQsTUFBTSxLQUFLLENBQUMsSUFBSSw0QkFBNEIsQ0FBQyxDQUFDLElBQUksQ0FDOUMsTUFBTSxDQUFFLE9BQU8sQ0FDZiwyQkFBMkIsQ0FBRSxXQUFXLENBRXhDLE1BQU0sQ0FBRSxJQUFJLGFBQWEsQ0FBQyxDQUMxQixLQUFLLENBQUUsSUFBSSxhQUFhLENBQzFCLENBQ0EsbUNBQXFCLE1BQU8sQ0FDMUIsT0FBTyxDQUFFLEdBQ1gsQ0FDQSwwQ0FBNkIsQ0FDM0IsT0FBTyxDQUFFLEdBQUcsQ0FFWixNQUFNLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxDQUNqQyxLQUFLLENBQUUsSUFBSSxvQkFBb0IsQ0FDakMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRG90LnN2ZWx0ZSJdfQ== */");
}
function create_fragment(ctx) {
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      attr_dev(button, "class", "sc-carousel-button sc-carousel-dot__dot svelte-yu7247");
      toggle_class(
        button,
        "sc-carousel-dot__dot_active",
        /*active*/
        ctx[0]
      );
      add_location(button, file, 7, 0, 99);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[1],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*active*/
      1) {
        toggle_class(
          button,
          "sc-carousel-dot__dot_active",
          /*active*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dot", slots, []);
  let { active = false } = $$props;
  const writable_props = ["active"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Dot> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("active" in $$props2)
      $$invalidate(0, active = $$props2.active);
  };
  $$self.$capture_state = () => ({ active });
  $$self.$inject_state = ($$props2) => {
    if ("active" in $$props2)
      $$invalidate(0, active = $$props2.active);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [active, click_handler];
}
var Dot = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { active: 0 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dot",
      options,
      id: create_fragment.name
    });
  }
  get active() {
    throw new Error("<Dot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Dot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dot_default = Dot;

// node_modules/svelte-carousel/src/components/Dots/Dots.svelte
var file2 = "node_modules\\svelte-carousel\\src\\components\\Dots\\Dots.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1oj5bge", ".sc-carousel-dots__container.svelte-1oj5bge{display:flex;align-items:center;justify-content:center;flex-wrap:wrap;padding:0 30px}.sc-carousel-dots__dot-container.svelte-1oj5bge{height:calc(var(--sc-dot-size) + 14px);width:calc(var(--sc-dot-size) + 10px);display:flex;align-items:center;justify-content:center}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG90cy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBaUNFLDJDQUE2QixDQUMzQixPQUFPLENBQUUsSUFBSSxDQUNiLFdBQVcsQ0FBRSxNQUFNLENBQ25CLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsT0FBTyxDQUFFLENBQUMsQ0FBQyxJQUNiLENBQ0EsK0NBQWlDLENBQy9CLE1BQU0sQ0FBRSxLQUFLLElBQUksYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUN2QyxLQUFLLENBQUUsS0FBSyxJQUFJLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FDdEMsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFDbkIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRG90cy5zdmVsdGUiXX0= */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  child_ctx[7] = i;
  return child_ctx;
}
function create_each_block(key_1, ctx) {
  let div;
  let dot;
  let t;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[3](
        /*pageIndex*/
        ctx[7]
      )
    );
  }
  dot = new Dot_default({
    props: {
      active: (
        /*currentPageIndex*/
        ctx[1] === /*pageIndex*/
        ctx[7]
      )
    },
    $$inline: true
  });
  dot.$on("click", click_handler);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div = element("div");
      create_component(dot.$$.fragment);
      t = space();
      attr_dev(div, "class", "sc-carousel-dots__dot-container svelte-1oj5bge");
      add_location(div, file2, 23, 4, 515);
      this.first = div;
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(dot, div, null);
      append_dev(div, t);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const dot_changes = {};
      if (dirty & /*currentPageIndex, pagesCount*/
      3)
        dot_changes.active = /*currentPageIndex*/
        ctx[1] === /*pageIndex*/
        ctx[7];
      dot.$set(dot_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dot.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dot.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(dot);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(23:2) {#each Array(pagesCount) as _, pageIndex (pageIndex)}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = Array(
    /*pagesCount*/
    ctx[0]
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*pageIndex*/
    ctx2[7]
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "sc-carousel-dots__container svelte-1oj5bge");
      add_location(div, file2, 21, 0, 411);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*currentPageIndex, Array, pagesCount, handleDotClick*/
      7) {
        each_value = Array(
          /*pagesCount*/
          ctx2[0]
        );
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dots", slots, []);
  const dispatch = createEventDispatcher();
  let { pagesCount = 1 } = $$props;
  let { currentPageIndex = 0 } = $$props;
  function handleDotClick(pageIndex) {
    dispatch("pageChange", pageIndex);
  }
  const writable_props = ["pagesCount", "currentPageIndex"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Dots> was created with unknown prop '${key}'`);
  });
  const click_handler = (pageIndex) => handleDotClick(pageIndex);
  $$self.$$set = ($$props2) => {
    if ("pagesCount" in $$props2)
      $$invalidate(0, pagesCount = $$props2.pagesCount);
    if ("currentPageIndex" in $$props2)
      $$invalidate(1, currentPageIndex = $$props2.currentPageIndex);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    Dot: Dot_default,
    dispatch,
    pagesCount,
    currentPageIndex,
    handleDotClick
  });
  $$self.$inject_state = ($$props2) => {
    if ("pagesCount" in $$props2)
      $$invalidate(0, pagesCount = $$props2.pagesCount);
    if ("currentPageIndex" in $$props2)
      $$invalidate(1, currentPageIndex = $$props2.currentPageIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [pagesCount, currentPageIndex, handleDotClick, click_handler];
}
var Dots = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { pagesCount: 0, currentPageIndex: 1 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dots",
      options,
      id: create_fragment2.name
    });
  }
  get pagesCount() {
    throw new Error("<Dots>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pagesCount(value) {
    throw new Error("<Dots>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get currentPageIndex() {
    throw new Error("<Dots>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentPageIndex(value) {
    throw new Error("<Dots>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dots_default = Dots;

// node_modules/svelte-carousel/src/direction.js
var PREV = "prev";
var NEXT = "next";

// node_modules/svelte-carousel/src/components/Arrow/Arrow.svelte
var file3 = "node_modules\\svelte-carousel\\src\\components\\Arrow\\Arrow.svelte";
function add_css3(target) {
  append_styles(target, "svelte-9ztt4p", ":root{--sc-arrow-size:2px}.sc-carousel-arrow__circle.svelte-9ztt4p{width:20px;height:20px;border-radius:50%;background-color:var(--sc-color-rgb-light-50p);display:flex;align-items:center;justify-content:center;transition:opacity 100ms ease;cursor:pointer;-webkit-tap-highlight-color:transparent}.sc-carousel-arrow__circle.svelte-9ztt4p:hover{opacity:0.9}.sc-carousel-arrow__arrow.svelte-9ztt4p{border:solid var(--sc-color-hex-dark);border-width:0 var(--sc-arrow-size) var(--sc-arrow-size) 0;padding:var(--sc-arrow-size);position:relative}.sc-carousel-arrow__arrow-next.svelte-9ztt4p{transform:rotate(-45deg);left:calc(var(--sc-arrow-size) / -2)}.sc-carousel-arrow__arrow-prev.svelte-9ztt4p{transform:rotate(135deg);right:calc(var(--sc-arrow-size) / -2)}.sc-carousel-arrow__circle_disabled.svelte-9ztt4p,.sc-carousel-arrow__circle_disabled.svelte-9ztt4p:hover{opacity:0.5}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXJyb3cuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTJCRSxLQUFNLENBQ0osZUFBZSxDQUFFLEdBQ25CLENBQ0Esd0NBQTJCLENBQ3pCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixhQUFhLENBQUUsR0FBRyxDQUNsQixnQkFBZ0IsQ0FBRSxJQUFJLHdCQUF3QixDQUFDLENBQy9DLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsVUFBVSxDQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUM5QixNQUFNLENBQUUsT0FBTyxDQUNmLDJCQUEyQixDQUFFLFdBQy9CLENBQ0Esd0NBQTBCLE1BQU8sQ0FDL0IsT0FBTyxDQUFFLEdBQ1gsQ0FDQSx1Q0FBMEIsQ0FDeEIsTUFBTSxDQUFFLEtBQUssQ0FBQyxJQUFJLG1CQUFtQixDQUFDLENBQ3RDLFlBQVksQ0FBRSxDQUFDLENBQUMsSUFBSSxlQUFlLENBQUMsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FDM0QsT0FBTyxDQUFFLElBQUksZUFBZSxDQUFDLENBQzdCLFFBQVEsQ0FBRSxRQUNaLENBQ0EsNENBQStCLENBQzdCLFNBQVMsQ0FBRSxPQUFPLE1BQU0sQ0FBQyxDQUN6QixJQUFJLENBQUUsS0FBSyxJQUFJLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQ3RDLENBQ0EsNENBQStCLENBQzdCLFNBQVMsQ0FBRSxPQUFPLE1BQU0sQ0FBQyxDQUN6QixLQUFLLENBQUUsS0FBSyxJQUFJLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQ3ZDLENBQ0EsaURBQW1DLENBQ25DLGlEQUFtQyxNQUFPLENBQ3hDLE9BQU8sQ0FBRSxHQUNYIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkFycm93LnN2ZWx0ZSJdfQ== */");
}
function create_fragment3(ctx) {
  let button;
  let i;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      i = element("i");
      attr_dev(i, "class", "sc-carousel-arrow__arrow svelte-9ztt4p");
      toggle_class(
        i,
        "sc-carousel-arrow__arrow-next",
        /*direction*/
        ctx[0] === NEXT
      );
      toggle_class(
        i,
        "sc-carousel-arrow__arrow-prev",
        /*direction*/
        ctx[0] === PREV
      );
      add_location(i, file3, 19, 2, 393);
      attr_dev(button, "class", "sc-carousel-button sc-carousel-arrow__circle svelte-9ztt4p");
      toggle_class(
        button,
        "sc-carousel-arrow__circle_disabled",
        /*disabled*/
        ctx[1]
      );
      add_location(button, file3, 14, 0, 256);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      append_dev(button, i);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[2],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*direction, NEXT*/
      1) {
        toggle_class(
          i,
          "sc-carousel-arrow__arrow-next",
          /*direction*/
          ctx2[0] === NEXT
        );
      }
      if (dirty & /*direction, PREV*/
      1) {
        toggle_class(
          i,
          "sc-carousel-arrow__arrow-prev",
          /*direction*/
          ctx2[0] === PREV
        );
      }
      if (dirty & /*disabled*/
      2) {
        toggle_class(
          button,
          "sc-carousel-arrow__circle_disabled",
          /*disabled*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Arrow", slots, []);
  let { direction = NEXT } = $$props;
  let { disabled = false } = $$props;
  const writable_props = ["direction", "disabled"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Arrow> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("direction" in $$props2)
      $$invalidate(0, direction = $$props2.direction);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
  };
  $$self.$capture_state = () => ({ NEXT, PREV, direction, disabled });
  $$self.$inject_state = ($$props2) => {
    if ("direction" in $$props2)
      $$invalidate(0, direction = $$props2.direction);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [direction, disabled, click_handler];
}
var Arrow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { direction: 0, disabled: 1 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Arrow",
      options,
      id: create_fragment3.name
    });
  }
  get direction() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Arrow_default = Arrow;

// node_modules/svelte-carousel/src/components/Progress/Progress.svelte
var file4 = "node_modules\\svelte-carousel\\src\\components\\Progress\\Progress.svelte";
function add_css4(target) {
  append_styles(target, "svelte-nuyenl", ".sc-carousel-progress__indicator.svelte-nuyenl{height:100%;background-color:var(--sc-color-hex-dark-50p)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvZ3Jlc3Muc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW1CRSw4Q0FBaUMsQ0FDL0IsTUFBTSxDQUFFLElBQUksQ0FDWixnQkFBZ0IsQ0FBRSxJQUFJLHVCQUF1QixDQUMvQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJQcm9ncmVzcy5zdmVsdGUiXX0= */");
}
function create_fragment4(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sc-carousel-progress__indicator svelte-nuyenl");
      set_style(
        div,
        "width",
        /*width*/
        ctx[0] + "%"
      );
      add_location(div, file4, 11, 0, 192);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*width*/
      1) {
        set_style(
          div,
          "width",
          /*width*/
          ctx2[0] + "%"
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var MAX_PERCENT = 100;
function instance4($$self, $$props, $$invalidate) {
  let width;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Progress", slots, []);
  let { value = 0 } = $$props;
  const writable_props = ["value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Progress> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
  };
  $$self.$capture_state = () => ({ MAX_PERCENT, value, width });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    2) {
      $:
        $$invalidate(0, width = Math.min(Math.max(value * MAX_PERCENT, 0), MAX_PERCENT));
    }
  };
  return [width, value];
}
var Progress = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { value: 1 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Progress",
      options,
      id: create_fragment4.name
    });
  }
  get value() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Progress_default = Progress;

// node_modules/svelte-carousel/src/actions/swipeable/event.js
function addStartEventListener(source, cb) {
  source.addEventListener("mousedown", cb);
  source.addEventListener("touchstart", cb, { passive: true });
}
function removeStartEventListener(source, cb) {
  source.removeEventListener("mousedown", cb);
  source.removeEventListener("touchstart", cb);
}
function addEndEventListener(source, cb) {
  source.addEventListener("mouseup", cb);
  source.addEventListener("touchend", cb);
}
function removeEndEventListener(source, cb) {
  source.removeEventListener("mouseup", cb);
  source.removeEventListener("touchend", cb);
}
function addMoveEventListener(source, cb) {
  source.addEventListener("mousemove", cb);
  source.addEventListener("touchmove", cb);
}
function removeMoveEventListener(source, cb) {
  source.removeEventListener("mousemove", cb);
  source.removeEventListener("touchmove", cb);
}

// node_modules/svelte-carousel/src/utils/event.js
function createDispatcher(source) {
  return function(event, data) {
    source.dispatchEvent(
      new CustomEvent(event, {
        detail: data
      })
    );
  };
}

// node_modules/svelte-carousel/src/units.js
var TAP_DURATION_MS = 110;
var TAP_MOVEMENT_PX = 9;
var SWIPE_MIN_DURATION_MS = 111;
var SWIPE_MIN_DISTANCE_PX = 20;

// node_modules/svelte-carousel/src/actions/swipeable/swipeable.js
function getCoords(event) {
  if ("TouchEvent" in window && event instanceof TouchEvent) {
    const touch = event.touches[0];
    return {
      x: touch ? touch.clientX : 0,
      y: touch ? touch.clientY : 0
    };
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function swipeable(node, { thresholdProvider }) {
  const dispatch = createDispatcher(node);
  let x;
  let y;
  let moved = 0;
  let swipeStartedAt;
  let isTouching = false;
  function isValidSwipe() {
    const swipeDurationMs = Date.now() - swipeStartedAt;
    return swipeDurationMs >= SWIPE_MIN_DURATION_MS && Math.abs(moved) >= SWIPE_MIN_DISTANCE_PX;
  }
  function handleDown(event) {
    swipeStartedAt = Date.now();
    moved = 0;
    isTouching = true;
    const coords = getCoords(event);
    x = coords.x;
    y = coords.y;
    dispatch("swipeStart", { x, y });
    addMoveEventListener(window, handleMove);
    addEndEventListener(window, handleUp);
  }
  function handleMove(event) {
    if (!isTouching)
      return;
    const coords = getCoords(event);
    const dx = coords.x - x;
    const dy = coords.y - y;
    x = coords.x;
    y = coords.y;
    dispatch("swipeMove", { x, y, dx, dy });
    if (dx !== 0 && Math.sign(dx) !== Math.sign(moved)) {
      moved = 0;
    }
    moved += dx;
    if (Math.abs(moved) > thresholdProvider()) {
      dispatch("swipeThresholdReached", { direction: moved > 0 ? PREV : NEXT });
      removeEndEventListener(window, handleUp);
      removeMoveEventListener(window, handleMove);
    }
  }
  function handleUp(event) {
    removeEndEventListener(window, handleUp);
    removeMoveEventListener(window, handleMove);
    isTouching = false;
    if (!isValidSwipe()) {
      dispatch("swipeFailed");
      return;
    }
    const coords = getCoords(event);
    dispatch("swipeEnd", { x: coords.x, y: coords.y });
  }
  addStartEventListener(node, handleDown);
  return {
    destroy() {
      removeStartEventListener(node, handleDown);
    }
  };
}

// node_modules/svelte-carousel/src/actions/hoverable/event.js
function addHoverInEventListener(source, cb) {
  source.addEventListener("mouseenter", cb);
}
function removeHoverInEventListener(source, cb) {
  source.removeEventListener("mouseenter", cb);
}
function addHoverOutEventListener(source, cb) {
  source.addEventListener("mouseleave", cb);
}
function removeHoverOutEventListener(source, cb) {
  source.removeEventListener("mouseleave", cb);
}

// node_modules/svelte-carousel/src/actions/hoverable/hoverable.js
function hoverable(node) {
  const dispatch = createDispatcher(node);
  function handleHoverIn() {
    addHoverOutEventListener(node, handleHoverOut);
    dispatch("hovered", { value: true });
  }
  function handleHoverOut() {
    dispatch("hovered", { value: false });
    removeHoverOutEventListener(node, handleHoverOut);
  }
  addHoverInEventListener(node, handleHoverIn);
  return {
    destroy() {
      removeHoverInEventListener(node, handleHoverIn);
      removeHoverOutEventListener(node, handleHoverOut);
    }
  };
}

// node_modules/svelte-carousel/src/utils/math.js
var getDistance = (p1, p2) => {
  const xDist = p2.x - p1.x;
  const yDist = p2.y - p1.y;
  return Math.sqrt(xDist * xDist + yDist * yDist);
};
function getValueInRange(min, value, max) {
  return Math.max(min, Math.min(value, max));
}

// node_modules/svelte-carousel/src/actions/tappable/event.js
function addFocusinEventListener(source, cb) {
  source.addEventListener("touchstart", cb, { passive: true });
}
function removeFocusinEventListener(source, cb) {
  source.removeEventListener("touchstart", cb);
}
function addFocusoutEventListener(source, cb) {
  source.addEventListener("touchend", cb);
}
function removeFocusoutEventListener(source, cb) {
  source.removeEventListener("touchend", cb);
}

// node_modules/svelte-carousel/src/actions/tappable/tappable.js
function tappable(node) {
  const dispatch = createDispatcher(node);
  let tapStartedAt = 0;
  let tapStartPos = { x: 0, y: 0 };
  function getIsValidTap({
    tapEndedAt,
    tapEndedPos
  }) {
    const tapTime = tapEndedAt - tapStartedAt;
    const tapDist = getDistance(tapStartPos, tapEndedPos);
    return tapTime <= TAP_DURATION_MS && tapDist <= TAP_MOVEMENT_PX;
  }
  function handleTapstart(event) {
    tapStartedAt = Date.now();
    const touch = event.touches[0];
    tapStartPos = { x: touch.clientX, y: touch.clientY };
    addFocusoutEventListener(node, handleTapend);
  }
  function handleTapend(event) {
    removeFocusoutEventListener(node, handleTapend);
    const touch = event.changedTouches[0];
    if (getIsValidTap({
      tapEndedAt: Date.now(),
      tapEndedPos: { x: touch.clientX, y: touch.clientY }
    })) {
      dispatch("tapped");
    }
  }
  addFocusinEventListener(node, handleTapstart);
  return {
    destroy() {
      removeFocusinEventListener(node, handleTapstart);
      removeFocusoutEventListener(node, handleTapend);
    }
  };
}

// node_modules/svelte-carousel/src/utils/page.js
function _getCurrentPageIndexByCurrentParticleIndexInfinite({
  currentParticleIndex,
  particlesCount,
  clonesCountHead,
  clonesCountTotal,
  particlesToScroll
}) {
  if (currentParticleIndex === particlesCount - clonesCountHead)
    return 0;
  if (currentParticleIndex === 0)
    return _getPagesCountByParticlesCountInfinite({
      particlesCountWithoutClones: particlesCount - clonesCountTotal,
      particlesToScroll
    }) - 1;
  return Math.floor((currentParticleIndex - clonesCountHead) / particlesToScroll);
}
function _getCurrentPageIndexByCurrentParticleIndexLimited({
  currentParticleIndex,
  particlesToScroll
}) {
  return Math.ceil(currentParticleIndex / particlesToScroll);
}
function getCurrentPageIndexByCurrentParticleIndex({
  currentParticleIndex,
  particlesCount,
  clonesCountHead,
  clonesCountTotal,
  infinite,
  particlesToScroll
}) {
  return infinite ? _getCurrentPageIndexByCurrentParticleIndexInfinite({
    currentParticleIndex,
    particlesCount,
    clonesCountHead,
    clonesCountTotal,
    particlesToScroll
  }) : _getCurrentPageIndexByCurrentParticleIndexLimited({
    currentParticleIndex,
    particlesToScroll
  });
}
function _getPagesCountByParticlesCountInfinite({
  particlesCountWithoutClones,
  particlesToScroll
}) {
  return Math.ceil(particlesCountWithoutClones / particlesToScroll);
}
function _getPagesCountByParticlesCountLimited({
  particlesCountWithoutClones,
  particlesToScroll,
  particlesToShow
}) {
  const partialPageSize = getPartialPageSize({
    particlesCountWithoutClones,
    particlesToScroll,
    particlesToShow
  });
  return Math.ceil(particlesCountWithoutClones / particlesToScroll) - partialPageSize;
}
function getPagesCountByParticlesCount({
  infinite,
  particlesCountWithoutClones,
  particlesToScroll,
  particlesToShow
}) {
  return infinite ? _getPagesCountByParticlesCountInfinite({
    particlesCountWithoutClones,
    particlesToScroll
  }) : _getPagesCountByParticlesCountLimited({
    particlesCountWithoutClones,
    particlesToScroll,
    particlesToShow
  });
}
function _getParticleIndexByPageIndexInfinite({
  pageIndex,
  clonesCountHead,
  clonesCountTail,
  particlesToScroll,
  particlesCount
}) {
  return getValueInRange(
    0,
    Math.min(clonesCountHead + pageIndex * particlesToScroll, particlesCount - clonesCountTail),
    particlesCount - 1
  );
}
function _getParticleIndexByPageIndexLimited({
  pageIndex,
  particlesToScroll,
  particlesCount,
  particlesToShow
}) {
  return getValueInRange(
    0,
    Math.min(pageIndex * particlesToScroll, particlesCount - particlesToShow),
    particlesCount - 1
  );
}
function getParticleIndexByPageIndex({
  infinite,
  pageIndex,
  clonesCountHead,
  clonesCountTail,
  particlesToScroll,
  particlesCount,
  particlesToShow
}) {
  return infinite ? _getParticleIndexByPageIndexInfinite({
    pageIndex,
    clonesCountHead,
    clonesCountTail,
    particlesToScroll,
    particlesCount
  }) : _getParticleIndexByPageIndexLimited({
    pageIndex,
    particlesToScroll,
    particlesCount,
    particlesToShow
  });
}
function applyParticleSizes({
  particlesContainerChildren,
  particleWidth
}) {
  for (let particleIndex = 0; particleIndex < particlesContainerChildren.length; particleIndex++) {
    particlesContainerChildren[particleIndex].style.minWidth = `${particleWidth}px`;
    particlesContainerChildren[particleIndex].style.maxWidth = `${particleWidth}px`;
  }
}
function getPartialPageSize({
  particlesToScroll,
  particlesToShow,
  particlesCountWithoutClones
}) {
  const overlap = particlesToScroll - particlesToShow;
  let particlesCount = particlesToShow;
  while (true) {
    const diff = particlesCountWithoutClones - particlesCount - overlap;
    if (diff < particlesToShow) {
      return Math.max(diff, 0);
    }
    particlesCount += particlesToShow + overlap;
  }
}
function createResizeObserver(onResize) {
  return new ResizeObserver((entries) => {
    onResize({
      width: entries[0].contentRect.width
    });
  });
}

// node_modules/svelte-carousel/src/utils/clones.js
function getClones({
  clonesCountHead,
  clonesCountTail,
  particlesContainerChildren
}) {
  const clonesToAppend = [];
  for (let i = 0; i < clonesCountTail; i++) {
    clonesToAppend.push(particlesContainerChildren[i].cloneNode(true));
  }
  const clonesToPrepend = [];
  const len = particlesContainerChildren.length;
  for (let i = len - 1; i > len - 1 - clonesCountHead; i--) {
    clonesToPrepend.push(particlesContainerChildren[i].cloneNode(true));
  }
  return {
    clonesToAppend,
    clonesToPrepend
  };
}
function applyClones({
  particlesContainer,
  clonesToAppend,
  clonesToPrepend
}) {
  for (let i = 0; i < clonesToAppend.length; i++) {
    particlesContainer.append(clonesToAppend[i]);
  }
  for (let i = 0; i < clonesToPrepend.length; i++) {
    particlesContainer.prepend(clonesToPrepend[i]);
  }
}
function getClonesCount({
  infinite,
  particlesToShow,
  partialPageSize
}) {
  const clonesCount = infinite ? {
    // need to round with ceil as particlesToShow, particlesToShow can be floating (e.g. 1.5, 3.75)
    head: Math.ceil(partialPageSize || particlesToShow),
    tail: Math.ceil(particlesToShow)
  } : {
    head: 0,
    tail: 0
  };
  return {
    ...clonesCount,
    total: clonesCount.head + clonesCount.tail
  };
}

// node_modules/svelte-carousel/src/utils/object.js
var get = (object, fieldName, defaultValue) => {
  if (object && object.hasOwnProperty(fieldName)) {
    return object[fieldName];
  }
  if (defaultValue === void 0) {
    throw new Error(`Required arg "${fieldName}" was not provided`);
  }
  return defaultValue;
};
var switcher = (description) => (key) => {
  description[key] && description[key]();
};

// node_modules/easy-reactive/src/simply-reactive.js
var import_lodash2 = __toESM(require_lodash(), 1);
var import_lodash3 = __toESM(require_lodash2(), 1);

// node_modules/easy-reactive/src/utils/object.js
var import_lodash = __toESM(require_lodash3(), 1);
var depsAreEqual = (deps1, deps2) => {
  return (0, import_lodash.default)(deps1, deps2);
};
var getDepNames = (deps) => {
  return Object.keys(deps || {});
};
var getUpdatedDeps = (depNames, currentData) => {
  const updatedDeps = {};
  depNames.forEach((depName) => {
    updatedDeps[depName] = currentData[depName];
  });
  return updatedDeps;
};

// node_modules/easy-reactive/src/utils/subscription.js
var createSubscription = () => {
  const subscribers = {};
  const memoDependency = (target, dep) => {
    const { watcherName, fn } = target;
    const { prop, value } = dep;
    if (!subscribers[watcherName]) {
      subscribers[watcherName] = {
        deps: {},
        fn
      };
    }
    subscribers[watcherName].deps[prop] = value;
  };
  return {
    subscribers,
    subscribe(target, dep) {
      if (target) {
        memoDependency(target, dep);
      }
    },
    notify(data, prop) {
      Object.entries(subscribers).forEach(([watchName, { deps, fn }]) => {
        const depNames = getDepNames(deps);
        if (depNames.includes(prop)) {
          const updatedDeps = getUpdatedDeps(depNames, data);
          if (!depsAreEqual(deps, updatedDeps)) {
            subscribers[watchName].deps = updatedDeps;
            fn();
          }
        }
      });
    }
  };
};

// node_modules/easy-reactive/src/utils/watcher.js
var createTargetWatcher = () => {
  let target = null;
  return {
    targetWatcher(watcherName, fn) {
      target = {
        watcherName,
        fn
      };
      target.fn();
      target = null;
    },
    getTarget() {
      return target;
    }
  };
};

// node_modules/easy-reactive/src/simply-reactive.js
function simplyReactive(entities, options) {
  const data = (0, import_lodash2.default)(entities, "data", {});
  const watch = (0, import_lodash2.default)(entities, "watch", {});
  const methods = (0, import_lodash2.default)(entities, "methods", {});
  const onChange = (0, import_lodash2.default)(options, "onChange", () => {
  });
  const { subscribe, notify, subscribers } = createSubscription();
  const { targetWatcher, getTarget } = createTargetWatcher();
  let _data;
  const _methods = {};
  const getContext = () => ({
    data: _data,
    methods: _methods
  });
  let callingMethod = false;
  const methodWithFlags = (fn) => (...args) => {
    callingMethod = true;
    const result = fn(...args);
    callingMethod = false;
    return result;
  };
  Object.entries(methods).forEach(([methodName, methodItem]) => {
    _methods[methodName] = methodWithFlags(
      (...args) => methodItem(getContext(), ...args)
    );
    Object.defineProperty(_methods[methodName], "name", { value: methodName });
  });
  _data = new Proxy((0, import_lodash3.default)(data), {
    get(target, prop) {
      if (getTarget() && !callingMethod) {
        subscribe(getTarget(), { prop, value: target[prop] });
      }
      return Reflect.get(...arguments);
    },
    set(target, prop, value) {
      if (target[prop] === value) {
        return true;
      }
      Reflect.set(...arguments);
      if (!getTarget()) {
        onChange && onChange(prop, value);
        notify(_data, prop);
      }
      return true;
    }
  });
  Object.entries(watch).forEach(([watchName, watchItem]) => {
    targetWatcher(watchName, () => {
      watchItem(getContext());
    });
  });
  const output = [_data, _methods];
  output._internal = {
    _getSubscribers() {
      return subscribers;
    }
  };
  return output;
}

// node_modules/svelte-carousel/src/utils/lazy.js
function getIndexesOfParticlesWithoutClonesInPage({
  pageIndex,
  particlesToShow,
  particlesToScroll,
  particlesCount
}) {
  const overlap = pageIndex === 0 ? 0 : particlesToShow - particlesToScroll;
  const from = pageIndex * particlesToShow - pageIndex * overlap;
  const to = from + Math.max(particlesToShow, particlesToScroll) - 1;
  const indexes = [];
  for (let i = from; i <= Math.min(particlesCount - 1, to); i++) {
    indexes.push(i);
  }
  return indexes;
}
function getAdjacentIndexes({
  infinite,
  pageIndex,
  pagesCount,
  particlesCount,
  particlesToShow,
  particlesToScroll
}) {
  const _pageIndex = getValueInRange(0, pageIndex, pagesCount - 1);
  let rangeStart = _pageIndex - 1;
  let rangeEnd = _pageIndex + 1;
  rangeStart = infinite ? rangeStart < 0 ? pagesCount - 1 : rangeStart : Math.max(0, rangeStart);
  rangeEnd = infinite ? rangeEnd > pagesCount - 1 ? 0 : rangeEnd : Math.min(pagesCount - 1, rangeEnd);
  const pageIndexes = [.../* @__PURE__ */ new Set([
    rangeStart,
    _pageIndex,
    rangeEnd,
    // because of these values outputs for infinite/non-infinites are the same
    0,
    // needed to clone first page particles
    pagesCount - 1
    // needed to clone last page particles
  ])].sort((a, b) => a - b);
  const particleIndexes = pageIndexes.flatMap(
    (pageIndex2) => getIndexesOfParticlesWithoutClonesInPage({
      pageIndex: pageIndex2,
      particlesToShow,
      particlesToScroll,
      particlesCount
    })
  );
  return {
    pageIndexes,
    particleIndexes: [...new Set(particleIndexes)].sort((a, b) => a - b)
  };
}

// node_modules/svelte-carousel/src/utils/interval.js
var setIntervalImmediate = (fn, ms) => {
  fn();
  return setInterval(fn, ms);
};

// node_modules/svelte-carousel/src/utils/ProgressManager.js
var STEP_MS = 35;
var MAX_VALUE = 1;
var ProgressManager = class {
  constructor({ onProgressValueChange }) {
    this._onProgressValueChange = onProgressValueChange;
    this._autoplayDuration;
    this._onProgressValueChange;
    this._interval;
    this._paused = false;
  }
  setAutoplayDuration(autoplayDuration) {
    this._autoplayDuration = autoplayDuration;
  }
  start(onFinish) {
    return new Promise((resolve) => {
      this.reset();
      const stepMs = Math.min(STEP_MS, Math.max(this._autoplayDuration, 1));
      let progress = -stepMs;
      this._interval = setIntervalImmediate(async () => {
        if (this._paused) {
          return;
        }
        progress += stepMs;
        const value = progress / this._autoplayDuration;
        this._onProgressValueChange(value);
        if (value > MAX_VALUE) {
          this.reset();
          await onFinish();
          resolve();
        }
      }, stepMs);
    });
  }
  pause() {
    this._paused = true;
  }
  resume() {
    this._paused = false;
  }
  reset() {
    clearInterval(this._interval);
    this._onProgressValueChange(MAX_VALUE);
  }
};

// node_modules/svelte-carousel/src/components/Carousel/createCarousel.js
function createCarousel(onChange) {
  const progressManager = new ProgressManager({
    onProgressValueChange: (value) => {
      onChange("progressValue", 1 - value);
    }
  });
  const reactive = simplyReactive(
    {
      data: {
        particlesCountWithoutClones: 0,
        particlesToShow: 1,
        // normalized
        particlesToShowInit: 1,
        // initial value
        particlesToScroll: 1,
        // normalized
        particlesToScrollInit: 1,
        // initial value
        particlesCount: 1,
        currentParticleIndex: 1,
        infinite: false,
        autoplayDuration: 1e3,
        clonesCountHead: 0,
        clonesCountTail: 0,
        clonesCountTotal: 0,
        partialPageSize: 1,
        currentPageIndex: 1,
        pagesCount: 1,
        pauseOnFocus: false,
        focused: false,
        autoplay: false,
        autoplayDirection: "next",
        disabled: false,
        // disable page change while animation is in progress
        durationMsInit: 1e3,
        durationMs: 1e3,
        offset: 0,
        particleWidth: 0,
        loaded: []
      },
      watch: {
        setLoaded({ data: data2 }) {
          data2.loaded = getAdjacentIndexes({
            infinite: data2.infinite,
            pageIndex: data2.currentPageIndex,
            pagesCount: data2.pagesCount,
            particlesCount: data2.particlesCountWithoutClones,
            particlesToShow: data2.particlesToShow,
            particlesToScroll: data2.particlesToScroll
          }).particleIndexes;
        },
        setCurrentPageIndex({ data: data2 }) {
          data2.currentPageIndex = getCurrentPageIndexByCurrentParticleIndex({
            currentParticleIndex: data2.currentParticleIndex,
            particlesCount: data2.particlesCount,
            clonesCountHead: data2.clonesCountHead,
            clonesCountTotal: data2.clonesCountTotal,
            infinite: data2.infinite,
            particlesToScroll: data2.particlesToScroll
          });
        },
        setPartialPageSize({ data: data2 }) {
          data2.partialPageSize = getPartialPageSize({
            particlesToScroll: data2.particlesToScroll,
            particlesToShow: data2.particlesToShow,
            particlesCountWithoutClones: data2.particlesCountWithoutClones
          });
        },
        setClonesCount({ data: data2 }) {
          const { head, tail } = getClonesCount({
            infinite: data2.infinite,
            particlesToShow: data2.particlesToShow,
            partialPageSize: data2.partialPageSize
          });
          data2.clonesCountHead = head;
          data2.clonesCountTail = tail;
          data2.clonesCountTotal = head + tail;
        },
        setProgressManagerAutoplayDuration({ data: data2 }) {
          progressManager.setAutoplayDuration(data2.autoplayDuration);
        },
        toggleProgressManager({ data: { pauseOnFocus, focused } }) {
          if (pauseOnFocus) {
            if (focused) {
              progressManager.pause();
            } else {
              progressManager.resume();
            }
          }
        },
        initDuration({ data: data2 }) {
          data2.durationMs = data2.durationMsInit;
        },
        applyAutoplay({ data: data2, methods: { _applyAutoplayIfNeeded } }) {
          data2.autoplay && _applyAutoplayIfNeeded(data2.autoplay);
        },
        setPagesCount({ data: data2 }) {
          data2.pagesCount = getPagesCountByParticlesCount({
            infinite: data2.infinite,
            particlesCountWithoutClones: data2.particlesCountWithoutClones,
            particlesToScroll: data2.particlesToScroll,
            particlesToShow: data2.particlesToShow
          });
        },
        setParticlesToShow({ data: data2 }) {
          data2.particlesToShow = getValueInRange(
            1,
            data2.particlesToShowInit,
            data2.particlesCountWithoutClones
          );
        },
        setParticlesToScroll({ data: data2 }) {
          data2.particlesToScroll = getValueInRange(
            1,
            data2.particlesToScrollInit,
            data2.particlesCountWithoutClones
          );
        }
      },
      methods: {
        _prev({ data: data2 }) {
          data2.currentParticleIndex = getParticleIndexByPageIndex({
            infinite: data2.infinite,
            pageIndex: data2.currentPageIndex - 1,
            clonesCountHead: data2.clonesCountHead,
            clonesCountTail: data2.clonesCountTail,
            particlesToScroll: data2.particlesToScroll,
            particlesCount: data2.particlesCount,
            particlesToShow: data2.particlesToShow
          });
        },
        _next({ data: data2 }) {
          data2.currentParticleIndex = getParticleIndexByPageIndex({
            infinite: data2.infinite,
            pageIndex: data2.currentPageIndex + 1,
            clonesCountHead: data2.clonesCountHead,
            clonesCountTail: data2.clonesCountTail,
            particlesToScroll: data2.particlesToScroll,
            particlesCount: data2.particlesCount,
            particlesToShow: data2.particlesToShow
          });
        },
        _moveToParticle({ data: data2 }, particleIndex) {
          data2.currentParticleIndex = getValueInRange(
            0,
            particleIndex,
            data2.particlesCount - 1
          );
        },
        toggleFocused({ data: data2 }) {
          data2.focused = !data2.focused;
        },
        async _applyAutoplayIfNeeded({ data: data2, methods: methods2 }) {
          if (!data2.infinite && (data2.autoplayDirection === NEXT && data2.currentParticleIndex === data2.particlesCount - 1 || data2.autoplayDirection === PREV && data2.currentParticleIndex === 0)) {
            progressManager.reset();
            return;
          }
          if (data2.autoplay) {
            const onFinish = () => switcher({
              [NEXT]: async () => methods2.showNextPage(),
              [PREV]: async () => methods2.showPrevPage()
            })(data2.autoplayDirection);
            await progressManager.start(onFinish);
          }
        },
        // makes delayed jump to 1st or last element
        async _jumpIfNeeded({ data: data2, methods: methods2 }) {
          let jumped = false;
          if (data2.infinite) {
            if (data2.currentParticleIndex === 0) {
              await methods2.showParticle(
                data2.particlesCount - data2.clonesCountTotal,
                {
                  animated: false
                }
              );
              jumped = true;
            } else if (data2.currentParticleIndex === data2.particlesCount - data2.clonesCountTail) {
              await methods2.showParticle(data2.clonesCountHead, {
                animated: false
              });
              jumped = true;
            }
          }
          return jumped;
        },
        async changePage({ data: data2, methods: methods2 }, updateStoreFn, options) {
          progressManager.reset();
          if (data2.disabled)
            return;
          data2.disabled = true;
          updateStoreFn();
          await methods2.offsetPage({ animated: get(options, "animated", true) });
          data2.disabled = false;
          const jumped = await methods2._jumpIfNeeded();
          !jumped && methods2._applyAutoplayIfNeeded();
        },
        async showNextPage({ data: data2, methods: methods2 }, options) {
          if (data2.disabled)
            return;
          await methods2.changePage(methods2._next, options);
        },
        async showPrevPage({ data: data2, methods: methods2 }, options) {
          if (data2.disabled)
            return;
          await methods2.changePage(methods2._prev, options);
        },
        async showParticle({ methods: methods2 }, particleIndex, options) {
          await methods2.changePage(
            () => methods2._moveToParticle(particleIndex),
            options
          );
        },
        _getParticleIndexByPageIndex({ data: data2 }, pageIndex) {
          return getParticleIndexByPageIndex({
            infinite: data2.infinite,
            pageIndex,
            clonesCountHead: data2.clonesCountHead,
            clonesCountTail: data2.clonesCountTail,
            particlesToScroll: data2.particlesToScroll,
            particlesCount: data2.particlesCount,
            particlesToShow: data2.particlesToShow
          });
        },
        async showPage({ methods: methods2 }, pageIndex, options) {
          const particleIndex = methods2._getParticleIndexByPageIndex(pageIndex);
          await methods2.showParticle(particleIndex, options);
        },
        offsetPage({ data: data2 }, options) {
          const animated = get(options, "animated", true);
          return new Promise((resolve) => {
            data2.durationMs = animated ? data2.durationMsInit : 0;
            data2.offset = -data2.currentParticleIndex * data2.particleWidth;
            setTimeout(() => {
              resolve();
            }, data2.durationMs);
          });
        }
      }
    },
    {
      onChange
    }
  );
  const [data, methods] = reactive;
  return [{ data, progressManager }, methods, reactive._internal];
}
var createCarousel_default = createCarousel;

// node_modules/svelte-carousel/src/components/Carousel/Carousel.svelte
var { Error: Error_1 } = globals;
var file5 = "node_modules\\svelte-carousel\\src\\components\\Carousel\\Carousel.svelte";
function add_css5(target) {
  append_styles(target, "svelte-uwo0yk", ":root{--sc-color-rgb-light-50p:rgba(93, 93, 93, 0.5);--sc-color-rgb-light:#5d5d5d;--sc-color-hex-dark-50p:rgba(30, 30, 30, 0.5);--sc-color-hex-dark:#1e1e1e}.sc-carousel__carousel-container.svelte-uwo0yk{display:flex;width:100%;flex-direction:column;align-items:center}.sc-carousel__content-container.svelte-uwo0yk{position:relative;display:flex;width:100%}.sc-carousel__pages-window.svelte-uwo0yk{flex:1;display:flex;overflow:hidden;box-sizing:border-box;position:relative}.sc-carousel__pages-container.svelte-uwo0yk{width:100%;display:flex;transition-property:transform}.sc-carousel__arrow-container.svelte-uwo0yk{padding:5px;box-sizing:border-box;display:flex;align-items:center;justify-content:center}.sc-carousel-progress__container.svelte-uwo0yk{width:100%;height:5px;background-color:var(--sc-color-rgb-light-50p);position:absolute;bottom:0}.sc-carousel-button{all:unset;cursor:pointer}.sc-carousel-button:focus{outline:5px auto}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2Fyb3VzZWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTJVRSxLQUFNLENBQ0osd0JBQXdCLENBQUUscUJBQXFCLENBQy9DLG9CQUFvQixDQUFFLE9BQU8sQ0FDN0IsdUJBQXVCLENBQUUscUJBQXFCLENBQzlDLG1CQUFtQixDQUFFLE9BQ3ZCLENBQ0EsOENBQWlDLENBQy9CLE9BQU8sQ0FBRSxJQUFJLENBQ2IsS0FBSyxDQUFFLElBQUksQ0FDWCxjQUFjLENBQUUsTUFBTSxDQUN0QixXQUFXLENBQUUsTUFDZixDQUNBLDZDQUFnQyxDQUM5QixRQUFRLENBQUUsUUFBUSxDQUNsQixPQUFPLENBQUUsSUFBSSxDQUNiLEtBQUssQ0FBRSxJQUNULENBQ0Esd0NBQTJCLENBQ3pCLElBQUksQ0FBRSxDQUFDLENBQ1AsT0FBTyxDQUFFLElBQUksQ0FDYixRQUFRLENBQUUsTUFBTSxDQUNoQixVQUFVLENBQUUsVUFBVSxDQUN0QixRQUFRLENBQUUsUUFDWixDQUNBLDJDQUE4QixDQUM1QixLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxJQUFJLENBQ2IsbUJBQW1CLENBQUUsU0FDdkIsQ0FDQSwyQ0FBOEIsQ0FDNUIsT0FBTyxDQUFFLEdBQUcsQ0FDWixVQUFVLENBQUUsVUFBVSxDQUN0QixPQUFPLENBQUUsSUFBSSxDQUNiLFdBQVcsQ0FBRSxNQUFNLENBQ25CLGVBQWUsQ0FBRSxNQUNuQixDQUNBLDhDQUFpQyxDQUMvQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxHQUFHLENBQ1gsZ0JBQWdCLENBQUUsSUFBSSx3QkFBd0IsQ0FBQyxDQUMvQyxRQUFRLENBQUUsUUFBUSxDQUNsQixNQUFNLENBQUUsQ0FDVixDQUNRLG1CQUFxQixDQUMzQixHQUFHLENBQUUsS0FBSyxDQUNWLE1BQU0sQ0FBRSxPQUNWLENBQ1EseUJBQTJCLENBQ2pDLE9BQU8sQ0FBRSxHQUFHLENBQUMsSUFDZiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDYXJvdXNlbC5zdmVsdGUiXX0= */");
}
var get_dots_slot_changes = (dirty) => ({
  currentPageIndex: dirty[0] & /*currentPageIndex*/
  32,
  pagesCount: dirty[0] & /*pagesCount*/
  1024,
  loaded: dirty[0] & /*loaded*/
  64
});
var get_dots_slot_context = (ctx) => ({
  currentPageIndex: (
    /*currentPageIndex*/
    ctx[5]
  ),
  pagesCount: (
    /*pagesCount*/
    ctx[10]
  ),
  showPage: (
    /*handlePageChange*/
    ctx[15]
  ),
  loaded: (
    /*loaded*/
    ctx[6]
  )
});
var get_next_slot_changes = (dirty) => ({
  loaded: dirty[0] & /*loaded*/
  64,
  currentPageIndex: dirty[0] & /*currentPageIndex*/
  32
});
var get_next_slot_context = (ctx) => ({
  showNextPage: (
    /*methods*/
    ctx[14].showNextPage
  ),
  loaded: (
    /*loaded*/
    ctx[6]
  ),
  currentPageIndex: (
    /*currentPageIndex*/
    ctx[5]
  )
});
var get_default_slot_changes = (dirty) => ({
  loaded: dirty[0] & /*loaded*/
  64,
  currentPageIndex: dirty[0] & /*currentPageIndex*/
  32
});
var get_default_slot_context = (ctx) => ({
  loaded: (
    /*loaded*/
    ctx[6]
  ),
  currentPageIndex: (
    /*currentPageIndex*/
    ctx[5]
  )
});
var get_prev_slot_changes = (dirty) => ({
  loaded: dirty[0] & /*loaded*/
  64,
  currentPageIndex: dirty[0] & /*currentPageIndex*/
  32
});
var get_prev_slot_context = (ctx) => ({
  showPrevPage: (
    /*methods*/
    ctx[14].showPrevPage
  ),
  loaded: (
    /*loaded*/
    ctx[6]
  ),
  currentPageIndex: (
    /*currentPageIndex*/
    ctx[5]
  )
});
function create_if_block_3(ctx) {
  let current;
  const prev_slot_template = (
    /*#slots*/
    ctx[37].prev
  );
  const prev_slot = create_slot(
    prev_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_prev_slot_context
  );
  const prev_slot_or_fallback = prev_slot || fallback_block_2(ctx);
  const block = {
    c: function create() {
      if (prev_slot_or_fallback)
        prev_slot_or_fallback.c();
    },
    m: function mount(target, anchor) {
      if (prev_slot_or_fallback) {
        prev_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (prev_slot) {
        if (prev_slot.p && (!current || dirty[0] & /*loaded, currentPageIndex*/
        96 | dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            prev_slot,
            prev_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              prev_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_prev_slot_changes
            ),
            get_prev_slot_context
          );
        }
      } else {
        if (prev_slot_or_fallback && prev_slot_or_fallback.p && (!current || dirty[0] & /*infinite, currentPageIndex*/
        36)) {
          prev_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(prev_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(prev_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (prev_slot_or_fallback)
        prev_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(259:4) {#if arrows}",
    ctx
  });
  return block;
}
function fallback_block_2(ctx) {
  let div;
  let arrow;
  let current;
  arrow = new Arrow_default({
    props: {
      direction: "prev",
      disabled: !/*infinite*/
      ctx[2] && /*currentPageIndex*/
      ctx[5] === 0
    },
    $$inline: true
  });
  arrow.$on(
    "click",
    /*showPrevPage*/
    ctx[23]
  );
  const block = {
    c: function create() {
      div = element("div");
      create_component(arrow.$$.fragment);
      attr_dev(div, "class", "sc-carousel__arrow-container svelte-uwo0yk");
      add_location(div, file5, 260, 8, 6343);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(arrow, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const arrow_changes = {};
      if (dirty[0] & /*infinite, currentPageIndex*/
      36)
        arrow_changes.disabled = !/*infinite*/
        ctx2[2] && /*currentPageIndex*/
        ctx2[5] === 0;
      arrow.$set(arrow_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(arrow.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(arrow.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(arrow);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(260:60)           ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  let progress;
  let current;
  progress = new Progress_default({
    props: { value: (
      /*progressValue*/
      ctx[7]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(progress.$$.fragment);
      attr_dev(div, "class", "sc-carousel-progress__container svelte-uwo0yk");
      add_location(div, file5, 297, 8, 7492);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(progress, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const progress_changes = {};
      if (dirty[0] & /*progressValue*/
      128)
        progress_changes.value = /*progressValue*/
        ctx2[7];
      progress.$set(progress_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(progress.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(progress.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(progress);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(297:6) {#if autoplayProgressVisible}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let current;
  const next_slot_template = (
    /*#slots*/
    ctx[37].next
  );
  const next_slot = create_slot(
    next_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_next_slot_context
  );
  const next_slot_or_fallback = next_slot || fallback_block_1(ctx);
  const block = {
    c: function create() {
      if (next_slot_or_fallback)
        next_slot_or_fallback.c();
    },
    m: function mount(target, anchor) {
      if (next_slot_or_fallback) {
        next_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (next_slot) {
        if (next_slot.p && (!current || dirty[0] & /*loaded, currentPageIndex*/
        96 | dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            next_slot,
            next_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              next_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_next_slot_changes
            ),
            get_next_slot_context
          );
        }
      } else {
        if (next_slot_or_fallback && next_slot_or_fallback.p && (!current || dirty[0] & /*infinite, currentPageIndex, pagesCount*/
        1060)) {
          next_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(next_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(next_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (next_slot_or_fallback)
        next_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(303:4) {#if arrows}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let div;
  let arrow;
  let current;
  arrow = new Arrow_default({
    props: {
      direction: "next",
      disabled: !/*infinite*/
      ctx[2] && /*currentPageIndex*/
      ctx[5] === /*pagesCount*/
      ctx[10] - 1
    },
    $$inline: true
  });
  arrow.$on(
    "click",
    /*methods*/
    ctx[14].showNextPage
  );
  const block = {
    c: function create() {
      div = element("div");
      create_component(arrow.$$.fragment);
      attr_dev(div, "class", "sc-carousel__arrow-container svelte-uwo0yk");
      add_location(div, file5, 304, 8, 7714);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(arrow, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const arrow_changes = {};
      if (dirty[0] & /*infinite, currentPageIndex, pagesCount*/
      1060)
        arrow_changes.disabled = !/*infinite*/
        ctx2[2] && /*currentPageIndex*/
        ctx2[5] === /*pagesCount*/
        ctx2[10] - 1;
      arrow.$set(arrow_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(arrow.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(arrow.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(arrow);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(304:60)           ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let current;
  const dots_slot_template = (
    /*#slots*/
    ctx[37].dots
  );
  const dots_slot = create_slot(
    dots_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_dots_slot_context
  );
  const dots_slot_or_fallback = dots_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (dots_slot_or_fallback)
        dots_slot_or_fallback.c();
    },
    m: function mount(target, anchor) {
      if (dots_slot_or_fallback) {
        dots_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dots_slot) {
        if (dots_slot.p && (!current || dirty[0] & /*currentPageIndex, pagesCount, loaded*/
        1120 | dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            dots_slot,
            dots_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              dots_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_dots_slot_changes
            ),
            get_dots_slot_context
          );
        }
      } else {
        if (dots_slot_or_fallback && dots_slot_or_fallback.p && (!current || dirty[0] & /*pagesCount, currentPageIndex*/
        1056)) {
          dots_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dots_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dots_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (dots_slot_or_fallback)
        dots_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(315:2) {#if dots}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let dots_1;
  let current;
  dots_1 = new Dots_default({
    props: {
      pagesCount: (
        /*pagesCount*/
        ctx[10]
      ),
      currentPageIndex: (
        /*currentPageIndex*/
        ctx[5]
      )
    },
    $$inline: true
  });
  dots_1.$on(
    "pageChange",
    /*pageChange_handler*/
    ctx[41]
  );
  const block = {
    c: function create() {
      create_component(dots_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(dots_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dots_1_changes = {};
      if (dirty[0] & /*pagesCount*/
      1024)
        dots_1_changes.pagesCount = /*pagesCount*/
        ctx2[10];
      if (dirty[0] & /*currentPageIndex*/
      32)
        dots_1_changes.currentPageIndex = /*currentPageIndex*/
        ctx2[5];
      dots_1.$set(dots_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dots_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dots_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dots_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(321:5)         ",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let div3;
  let div2;
  let t0;
  let div1;
  let div0;
  let swipeable_action;
  let t1;
  let hoverable_action;
  let tappable_action;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*arrows*/
    ctx[1] && create_if_block_3(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[37].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_default_slot_context
  );
  let if_block1 = (
    /*autoplayProgressVisible*/
    ctx[3] && create_if_block_2(ctx)
  );
  let if_block2 = (
    /*arrows*/
    ctx[1] && create_if_block_1(ctx)
  );
  let if_block3 = (
    /*dots*/
    ctx[4] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div3 = element("div");
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      attr_dev(div0, "class", "sc-carousel__pages-container svelte-uwo0yk");
      set_style(div0, "transform", "translateX(" + /*offset*/
      ctx[8] + "px)");
      set_style(
        div0,
        "transition-duration",
        /*durationMs*/
        ctx[9] + "ms"
      );
      set_style(
        div0,
        "transition-timing-function",
        /*timingFunction*/
        ctx[0]
      );
      add_location(div0, file5, 279, 6, 6800);
      attr_dev(div1, "class", "sc-carousel__pages-window svelte-uwo0yk");
      add_location(div1, file5, 269, 4, 6592);
      attr_dev(div2, "class", "sc-carousel__content-container svelte-uwo0yk");
      add_location(div2, file5, 257, 2, 6209);
      attr_dev(div3, "class", "sc-carousel__carousel-container svelte-uwo0yk");
      add_location(div3, file5, 256, 0, 6160);
    },
    l: function claim(nodes) {
      throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      append_dev(div3, div2);
      if (if_block0)
        if_block0.m(div2, null);
      append_dev(div2, t0);
      append_dev(div2, div1);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[39](div0);
      append_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      ctx[40](div1);
      append_dev(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      append_dev(div3, t3);
      if (if_block3)
        if_block3.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(swipeable_action = swipeable.call(null, div0, {
            thresholdProvider: (
              /*swipeable_function*/
              ctx[38]
            )
          })),
          listen_dev(
            div0,
            "swipeStart",
            /*handleSwipeStart*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "swipeMove",
            /*handleSwipeMove*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "swipeEnd",
            /*handleSwipeEnd*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "swipeFailed",
            /*handleSwipeFailed*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "swipeThresholdReached",
            /*handleSwipeThresholdReached*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          action_destroyer(hoverable_action = hoverable.call(null, div1)),
          listen_dev(
            div1,
            "hovered",
            /*handleHovered*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          action_destroyer(tappable_action = tappable.call(null, div1)),
          listen_dev(
            div1,
            "tapped",
            /*handleTapped*/
            ctx[22],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*arrows*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*arrows*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*loaded, currentPageIndex*/
        96 | dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*offset*/
      256) {
        set_style(div0, "transform", "translateX(" + /*offset*/
        ctx2[8] + "px)");
      }
      if (!current || dirty[0] & /*durationMs*/
      512) {
        set_style(
          div0,
          "transition-duration",
          /*durationMs*/
          ctx2[9] + "ms"
        );
      }
      if (!current || dirty[0] & /*timingFunction*/
      1) {
        set_style(
          div0,
          "transition-timing-function",
          /*timingFunction*/
          ctx2[0]
        );
      }
      if (swipeable_action && is_function(swipeable_action.update) && dirty[0] & /*pageWindowWidth*/
      2048)
        swipeable_action.update.call(null, {
          thresholdProvider: (
            /*swipeable_function*/
            ctx2[38]
          )
        });
      if (
        /*autoplayProgressVisible*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*autoplayProgressVisible*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*arrows*/
        ctx2[1]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*arrows*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*dots*/
        ctx2[4]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*dots*/
          16) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div3, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[39](null);
      if (if_block1)
        if_block1.d();
      ctx[40](null);
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Carousel", slots, ["prev", "default", "next", "dots"]);
  let loaded = [];
  let currentPageIndex;
  let progressValue;
  let offset = 0;
  let durationMs = 0;
  let pagesCount = 1;
  const [{ data, progressManager }, methods, service] = createCarousel_default((key, value) => {
    switcher({
      "currentPageIndex": () => $$invalidate(5, currentPageIndex = value),
      "progressValue": () => $$invalidate(7, progressValue = value),
      "offset": () => $$invalidate(8, offset = value),
      "durationMs": () => $$invalidate(9, durationMs = value),
      "pagesCount": () => $$invalidate(10, pagesCount = value),
      "loaded": () => $$invalidate(6, loaded = value)
    })(key);
  });
  const dispatch = createEventDispatcher();
  let { timingFunction = "ease-in-out" } = $$props;
  let { arrows = true } = $$props;
  let { infinite = true } = $$props;
  let { initialPageIndex = 0 } = $$props;
  let { duration = 500 } = $$props;
  let { autoplay = false } = $$props;
  let { autoplayDuration = 3e3 } = $$props;
  let { autoplayDirection = NEXT } = $$props;
  let { pauseOnFocus = false } = $$props;
  let { autoplayProgressVisible = false } = $$props;
  let { dots = true } = $$props;
  let { swiping = true } = $$props;
  let { particlesToShow = 1 } = $$props;
  let { particlesToScroll = 1 } = $$props;
  async function goTo(pageIndex, options) {
    const animated = get(options, "animated", true);
    if (typeof pageIndex !== "number") {
      throw new Error("pageIndex should be a number");
    }
    await methods.showPage(pageIndex, { animated });
  }
  async function goToPrev(options) {
    const animated = get(options, "animated", true);
    await methods.showPrevPage({ animated });
  }
  async function goToNext(options) {
    const animated = get(options, "animated", true);
    await methods.showNextPage({ animated });
  }
  let pageWindowWidth = 0;
  let pageWindowElement;
  let particlesContainer;
  const pageWindowElementResizeObserver = createResizeObserver(({ width }) => {
    $$invalidate(11, pageWindowWidth = width);
    data.particleWidth = pageWindowWidth / data.particlesToShow;
    applyParticleSizes({
      particlesContainerChildren: particlesContainer.children,
      particleWidth: data.particleWidth
    });
    methods.offsetPage({ animated: false });
  });
  function addClones() {
    const { clonesToAppend, clonesToPrepend } = getClones({
      clonesCountHead: data.clonesCountHead,
      clonesCountTail: data.clonesCountTail,
      particlesContainerChildren: particlesContainer.children
    });
    applyClones({
      particlesContainer,
      clonesToAppend,
      clonesToPrepend
    });
  }
  onMount(() => {
    (async () => {
      await tick();
      if (particlesContainer && pageWindowElement) {
        data.particlesCountWithoutClones = particlesContainer.children.length;
        await tick();
        data.infinite && addClones();
        data.particlesCount = particlesContainer.children.length;
        methods.showPage(initialPageIndex, { animated: false });
        pageWindowElementResizeObserver.observe(pageWindowElement);
      }
    })();
  });
  onDestroy(() => {
    pageWindowElementResizeObserver.disconnect();
    progressManager.reset();
  });
  async function handlePageChange(pageIndex) {
    await methods.showPage(pageIndex, { animated: true });
  }
  function handleSwipeStart() {
    if (!swiping)
      return;
    data.durationMs = 0;
  }
  async function handleSwipeThresholdReached(event) {
    if (!swiping)
      return;
    await switcher({
      [NEXT]: methods.showNextPage,
      [PREV]: methods.showPrevPage
    })(event.detail.direction);
  }
  function handleSwipeMove(event) {
    if (!swiping)
      return;
    data.offset += event.detail.dx;
  }
  function handleSwipeEnd() {
    if (!swiping)
      return;
    methods.showParticle(data.currentParticleIndex);
  }
  async function handleSwipeFailed() {
    if (!swiping)
      return;
    await methods.offsetPage({ animated: true });
  }
  function handleHovered(event) {
    data.focused = event.detail.value;
  }
  function handleTapped() {
    methods.toggleFocused();
  }
  function showPrevPage() {
    methods.showPrevPage();
  }
  const writable_props = [
    "timingFunction",
    "arrows",
    "infinite",
    "initialPageIndex",
    "duration",
    "autoplay",
    "autoplayDuration",
    "autoplayDirection",
    "pauseOnFocus",
    "autoplayProgressVisible",
    "dots",
    "swiping",
    "particlesToShow",
    "particlesToScroll"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Carousel> was created with unknown prop '${key}'`);
  });
  const swipeable_function = () => pageWindowWidth / 3;
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      particlesContainer = $$value;
      $$invalidate(13, particlesContainer);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      pageWindowElement = $$value;
      $$invalidate(12, pageWindowElement);
    });
  }
  const pageChange_handler = (event) => handlePageChange(event.detail);
  $$self.$$set = ($$props2) => {
    if ("timingFunction" in $$props2)
      $$invalidate(0, timingFunction = $$props2.timingFunction);
    if ("arrows" in $$props2)
      $$invalidate(1, arrows = $$props2.arrows);
    if ("infinite" in $$props2)
      $$invalidate(2, infinite = $$props2.infinite);
    if ("initialPageIndex" in $$props2)
      $$invalidate(24, initialPageIndex = $$props2.initialPageIndex);
    if ("duration" in $$props2)
      $$invalidate(25, duration = $$props2.duration);
    if ("autoplay" in $$props2)
      $$invalidate(26, autoplay = $$props2.autoplay);
    if ("autoplayDuration" in $$props2)
      $$invalidate(27, autoplayDuration = $$props2.autoplayDuration);
    if ("autoplayDirection" in $$props2)
      $$invalidate(28, autoplayDirection = $$props2.autoplayDirection);
    if ("pauseOnFocus" in $$props2)
      $$invalidate(29, pauseOnFocus = $$props2.pauseOnFocus);
    if ("autoplayProgressVisible" in $$props2)
      $$invalidate(3, autoplayProgressVisible = $$props2.autoplayProgressVisible);
    if ("dots" in $$props2)
      $$invalidate(4, dots = $$props2.dots);
    if ("swiping" in $$props2)
      $$invalidate(30, swiping = $$props2.swiping);
    if ("particlesToShow" in $$props2)
      $$invalidate(31, particlesToShow = $$props2.particlesToShow);
    if ("particlesToScroll" in $$props2)
      $$invalidate(32, particlesToScroll = $$props2.particlesToScroll);
    if ("$$scope" in $$props2)
      $$invalidate(36, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    tick,
    createEventDispatcher,
    Dots: Dots_default,
    Arrow: Arrow_default,
    Progress: Progress_default,
    NEXT,
    PREV,
    swipeable,
    hoverable,
    tappable,
    applyParticleSizes,
    createResizeObserver,
    getClones,
    applyClones,
    get,
    switcher,
    createCarousel: createCarousel_default,
    loaded,
    currentPageIndex,
    progressValue,
    offset,
    durationMs,
    pagesCount,
    data,
    progressManager,
    methods,
    service,
    dispatch,
    timingFunction,
    arrows,
    infinite,
    initialPageIndex,
    duration,
    autoplay,
    autoplayDuration,
    autoplayDirection,
    pauseOnFocus,
    autoplayProgressVisible,
    dots,
    swiping,
    particlesToShow,
    particlesToScroll,
    goTo,
    goToPrev,
    goToNext,
    pageWindowWidth,
    pageWindowElement,
    particlesContainer,
    pageWindowElementResizeObserver,
    addClones,
    handlePageChange,
    handleSwipeStart,
    handleSwipeThresholdReached,
    handleSwipeMove,
    handleSwipeEnd,
    handleSwipeFailed,
    handleHovered,
    handleTapped,
    showPrevPage
  });
  $$self.$inject_state = ($$props2) => {
    if ("loaded" in $$props2)
      $$invalidate(6, loaded = $$props2.loaded);
    if ("currentPageIndex" in $$props2)
      $$invalidate(5, currentPageIndex = $$props2.currentPageIndex);
    if ("progressValue" in $$props2)
      $$invalidate(7, progressValue = $$props2.progressValue);
    if ("offset" in $$props2)
      $$invalidate(8, offset = $$props2.offset);
    if ("durationMs" in $$props2)
      $$invalidate(9, durationMs = $$props2.durationMs);
    if ("pagesCount" in $$props2)
      $$invalidate(10, pagesCount = $$props2.pagesCount);
    if ("timingFunction" in $$props2)
      $$invalidate(0, timingFunction = $$props2.timingFunction);
    if ("arrows" in $$props2)
      $$invalidate(1, arrows = $$props2.arrows);
    if ("infinite" in $$props2)
      $$invalidate(2, infinite = $$props2.infinite);
    if ("initialPageIndex" in $$props2)
      $$invalidate(24, initialPageIndex = $$props2.initialPageIndex);
    if ("duration" in $$props2)
      $$invalidate(25, duration = $$props2.duration);
    if ("autoplay" in $$props2)
      $$invalidate(26, autoplay = $$props2.autoplay);
    if ("autoplayDuration" in $$props2)
      $$invalidate(27, autoplayDuration = $$props2.autoplayDuration);
    if ("autoplayDirection" in $$props2)
      $$invalidate(28, autoplayDirection = $$props2.autoplayDirection);
    if ("pauseOnFocus" in $$props2)
      $$invalidate(29, pauseOnFocus = $$props2.pauseOnFocus);
    if ("autoplayProgressVisible" in $$props2)
      $$invalidate(3, autoplayProgressVisible = $$props2.autoplayProgressVisible);
    if ("dots" in $$props2)
      $$invalidate(4, dots = $$props2.dots);
    if ("swiping" in $$props2)
      $$invalidate(30, swiping = $$props2.swiping);
    if ("particlesToShow" in $$props2)
      $$invalidate(31, particlesToShow = $$props2.particlesToShow);
    if ("particlesToScroll" in $$props2)
      $$invalidate(32, particlesToScroll = $$props2.particlesToScroll);
    if ("pageWindowWidth" in $$props2)
      $$invalidate(11, pageWindowWidth = $$props2.pageWindowWidth);
    if ("pageWindowElement" in $$props2)
      $$invalidate(12, pageWindowElement = $$props2.pageWindowElement);
    if ("particlesContainer" in $$props2)
      $$invalidate(13, particlesContainer = $$props2.particlesContainer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*currentPageIndex*/
    32) {
      $: {
        dispatch("pageChange", currentPageIndex);
      }
    }
    if ($$self.$$.dirty[0] & /*infinite*/
    4) {
      $: {
        data.infinite = infinite;
      }
    }
    if ($$self.$$.dirty[0] & /*duration*/
    33554432) {
      $: {
        data.durationMsInit = duration;
      }
    }
    if ($$self.$$.dirty[0] & /*autoplay*/
    67108864) {
      $: {
        data.autoplay = autoplay;
      }
    }
    if ($$self.$$.dirty[0] & /*autoplayDuration*/
    134217728) {
      $: {
        data.autoplayDuration = autoplayDuration;
      }
    }
    if ($$self.$$.dirty[0] & /*autoplayDirection*/
    268435456) {
      $: {
        data.autoplayDirection = autoplayDirection;
      }
    }
    if ($$self.$$.dirty[0] & /*pauseOnFocus*/
    536870912) {
      $: {
        data.pauseOnFocus = pauseOnFocus;
      }
    }
    if ($$self.$$.dirty[1] & /*particlesToShow*/
    1) {
      $: {
        data.particlesToShowInit = particlesToShow;
      }
    }
    if ($$self.$$.dirty[1] & /*particlesToScroll*/
    2) {
      $: {
        data.particlesToScrollInit = particlesToScroll;
      }
    }
  };
  return [
    timingFunction,
    arrows,
    infinite,
    autoplayProgressVisible,
    dots,
    currentPageIndex,
    loaded,
    progressValue,
    offset,
    durationMs,
    pagesCount,
    pageWindowWidth,
    pageWindowElement,
    particlesContainer,
    methods,
    handlePageChange,
    handleSwipeStart,
    handleSwipeThresholdReached,
    handleSwipeMove,
    handleSwipeEnd,
    handleSwipeFailed,
    handleHovered,
    handleTapped,
    showPrevPage,
    initialPageIndex,
    duration,
    autoplay,
    autoplayDuration,
    autoplayDirection,
    pauseOnFocus,
    swiping,
    particlesToShow,
    particlesToScroll,
    goTo,
    goToPrev,
    goToNext,
    $$scope,
    slots,
    swipeable_function,
    div0_binding,
    div1_binding,
    pageChange_handler
  ];
}
var Carousel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        timingFunction: 0,
        arrows: 1,
        infinite: 2,
        initialPageIndex: 24,
        duration: 25,
        autoplay: 26,
        autoplayDuration: 27,
        autoplayDirection: 28,
        pauseOnFocus: 29,
        autoplayProgressVisible: 3,
        dots: 4,
        swiping: 30,
        particlesToShow: 31,
        particlesToScroll: 32,
        goTo: 33,
        goToPrev: 34,
        goToNext: 35
      },
      add_css5,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Carousel",
      options,
      id: create_fragment5.name
    });
  }
  get timingFunction() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set timingFunction(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrows() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrows(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get infinite() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set infinite(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialPageIndex() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialPageIndex(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplay() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplay(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplayDuration() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplayDuration(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplayDirection() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplayDirection(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pauseOnFocus() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pauseOnFocus(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplayProgressVisible() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplayProgressVisible(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dots() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dots(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swiping() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swiping(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get particlesToShow() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set particlesToShow(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get particlesToScroll() {
    throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set particlesToScroll(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get goTo() {
    return this.$$.ctx[33];
  }
  set goTo(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get goToPrev() {
    return this.$$.ctx[34];
  }
  set goToPrev(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get goToNext() {
    return this.$$.ctx[35];
  }
  set goToNext(value) {
    throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Carousel_default = Carousel;

// node_modules/svelte-carousel/src/main.js
var main_default = Carousel_default;
export {
  main_default as default
};
//# sourceMappingURL=svelte-carousel.js.map
